/*
 * system_IRQ.c
 *
 *  Created on: Oct 21, 2020
 *      Author: jair2
 */



/* Description
 * =====================================================================================================
 * Use the KL25Z micro-controller to call interruptions depending the inputs or time to ensure
 * communications and certain processes that require precise amounts of time     
 */



/*
	                                    Pin Definitions                                               
	====================================================================================
    Pin Number  |    Function    |         Assigned to          |     Functions by     |
	------------|----------------|------------------------------|----------------------|
	PTA1		|UART0_RX        |Terminal management           |Polling               |
	PTA2		|UART0_TX        |Terminal management           |Polling               |
	PTB0		|ADC0_SE8        |Reading temperature           |Polling               |
	PTB2		|I2C0_SCL        |Reading the IMU               |Interruption          |
	PTB3		|I2C0_SDA        |Reading the IMU               |Interruption          |
	PTC1		|TPM0_CH0        |Reading frequency motor1      |Interruption          |
	PTC2		|TPM0_CH1        |Reading frequency motor2      |Interruption          |
	PTC3		|TPM0_CH2        |Reading return pulse us sensor|Polling               |
	PTE0		|UART1_TX        |WiFi data shipping            |Interruption          |
	PTE1		|UART1_RX        |WiFi data receipt             |Interruption          |
	PTE2        |GPIO(output)    |Sending input pulse to sensor |Polling               |
	PTE20		|TPM1_CH0        |Sending PWM signal to motor1  |Polling               |
	PTE22		|TPM2_CH0        |Sending PWM signal to motor2  |polling               |
*/



// Libraries needed for the file 
//**************************************************************************************

#include "derivative.h"
#include "system_IRQ.h"
#include "system_functions.h"

//**************************************************************************************



// Variables used for monitoring the speed by encoders
//**************************************************************************************

unsigned short countA = 0;	
unsigned short countB = 0;
unsigned long rpmA;
unsigned long rpmB;

//**************************************************************************************



// Variables used for the ultra-sonic sensor
//**************************************************************************************

unsigned short t1;
unsigned short t2;
unsigned short tiempo_us;
unsigned short distancia;

//**************************************************************************************



// Variables used for controlling the motors
//**************************************************************************************
unsigned char paro;
extern unsigned short duty_cycleA;						//The duty_cycle of motor1
extern unsigned short duty_cycleB;						//The duty cycle of motor2
extern unsigned short periodo;

//**************************************************************************************



// Variables used for interpreting the strings from UART
//**************************************************************************************

extern char buffer[500];
extern char to_parse[100];
extern unsigned char found_char;
extern unsigned char buff_ind;
extern unsigned char messageComplete;

//**************************************************************************************



/*
==========================================================================================================
 * Name: 		FTM0_IRQHandler
 * Parameter: 	NONE
 * Returns: 	NONE
 * Description: Count the pulses generated by the encoder
==========================================================================================================
*/

void FTM0_IRQHandler(void)
{
	if ((1<<7) == (TPM0_C0SC & (1<<7) ))				//Determine if TPM0_CH0 caused the interruption
	{
		TPM0_C0SC|=(1<<7);								//Turn down flag
	
		countA++;										//Increase counter
	}
	
	if ((1<<7) == (TPM0_C1SC & (1<<7) ) )				//Determine if TPM0_CH1 caused the interruption
	{
		TPM0_C1SC|=(1<<7);								//Turn down flag
		
		countB++;										//Increase counter
	}
}



/*
==========================================================================================================
 * Name: 		PIT_IRQHandler
 * Parameter: 	NONE
 * Returns: 	NONE
 * Description: Upon 100ms recover data from all main sensors
==========================================================================================================
*/

void PIT_IRQHandler()
{

	//Code for monitoring the speed
	//__________________________________________________________________
	
	PIT_TFLG0|=(1<<0);									//Turn down flag

	rpmA = ((60*countA*100*26)/(11*468*17));			//Formula for RPM
	countA = 0;											//Reset counter
			
	rpmB = ((60*countB*100*26)/(11*468*17));			//Formula for RPM
	countB = 0;											//Reset counter
	
	//___________________________________________________________________
	
	
	
	//Code for measuring the ultra-sonic sensor
	//__________________________________________________________________
	
	pulse_generator ();
	
	do{}while ((TPM0_C2SC & (1<<7))==0);  				//Wait rising edge
	
	TPM0_C2SC|=(1<<7);									//Turn down flag
	TPM0_C2SC&=~(1<<2);									//Reset register
	TPM0_C2SC=(1<<3);									//Change to falling edge
	t1=TPM0_C2V;										//Save time
	
	do{}while ((TPM0_C2SC & (1<<7))==0);  				//Wait falling edge
	
	TPM0_C2SC|=(1<<7);									//Turn down flag
	t2=TPM0_C2V;										//Save time
	TPM0_C2SC&=~(1<<3);									//Reset register
	TPM0_C2SC=(1<<2);									//Change to rising edge
	
	tiempo_us= ((t2-t1)*250)/1000;						//Calculate time
	distancia=tiempo_us/58;								//Calculate distance
	TPM0_CNT = 1;										//Reset counter
	
	if (distancia<50)									//Condition depending distance
	{
		paro =1;										//Global variable to stay still 
		duty_cycleA = 10;								//Change duty cycle
		duty_cycleB = 10;								//Change duty cycle
		TPM1_C0V=((periodo*(100-duty_cycleA))/100);		//Physically change the speed
		TPM2_C0V=((periodo*(100-duty_cycleB))/100);		//Physically change the speed
	}
	else
	{
		paro = 0;										//Change global variable to stay still
		
	}
	
	//__________________________________________________________________
	
	
	
	//Recover data from IMU
	//__________________________________________________________________
	
	IMU_data();
	
	//__________________________________________________________________
}



/*
==========================================================================================================
 * Name: 		UART1_IRQHandler
 * Parameter: 	NONE
 * Returns: 	NONE
 * Description: UART finding
==========================================================================================================
*/

void UART1_IRQHandler()
{
	if (UART1_S1 & (1<<5))								//Receive data register full
	{
		char temp = UART1_D;                     		//Turn down flag and save data
		
		UART0_writeChar(temp);							//Send data to terminal
		
		buffer[buff_ind] = temp;                		//Saving read message into buffer
		buff_ind++;										//Increase counter to read complete message
		
		if (temp == to_parse[found_char])				//If coincidence found
		{ 
			found_char++;								//Increase counter to compare
		
			if (to_parse[found_char] == '\0')			//Until NULL symbol found
			{   
				buffer[buff_ind] = '\0';				//Add NULL symbol 
				found_char = 0;							//Reset counter
				messageComplete = 1;					//Confirm finding
				UART1_C2 &= ~(1<<5);             		//Disable interruption
			}
		}
		else
		{
			found_char = 0;                      		//Reset counter
		}
	}
}
